pub mod std {
   pub mod io {
      use core::io::stdout;
   
      pub fn print(value: &str) {
         io::stdout().write(value);
      }
   
      pub fn println(value: &str) {
         io::stdout().write(value);
         io::stdout().write("\n");
      }
   }
}

use std::io;

// defaults to other.lo or other/mod.lo
use other::something;
use testing::util;

#[path="other/another.lo"]
use another;

const MAX_VALUE: i64 = 100;
static GREETING: &str = "Hello";

// Type error: TypeMismatch { expected: "&str", found: "i32", location: "in function main" }
// even though its here
// when changing return type "location"
fn get_message(input: &str) -> &str {
   io::println(input);
    
   GREETING
}

// parse enums
pub enum Result<T, E> {
   Ok(T),
   Err(E),
}

pub enum Option<T> {
   None,
   Some(T),
}

fn test_patterns() {
   let success = Result::Ok(42);
   let failure = Result::Err("error message");
   let maybe = Option::Some(123);
   let nothing = Option::None;
   
   let result = match success {
      Result::Ok(n) => n,
      Result::Err(_) => -1,
   };
   
   
   let error_msg = match failure {
      Result::Ok(_) => "success",
      Result::Err(msg) => msg,
   };
   
   let opt_value = match maybe {
      Option::Some(x) => x,
      Option::None => 0,
    };
   
   let default = match nothing {
      Option::Some(x) => x,
      Option::None => 999,
   };
   
   io::println(result);     // should print 42
   io::println(error_msg);  // should print "error message"
   io::println(opt_value);  // should print 123
   io::println(default);    // should print 999
}

pub enum Shape {
   Circle(f64),
   Rectangle(f64, f64),
   Triangle { base: f64, height: f64 },
}

fn test_enums() {
   let circle = Shape::Circle(5.0);
   let rect = Shape::Rectangle(4.0, 6.0); // Runtime error: Enum variant with data must have exactly one argument
   let triangle = Shape::Triangle { base: 3.0, height: 4.0 }; // add support for this

   io::println(circle);
   io::println(rect);
   io::println(triangle);
}

fn test_assignment(val: &mut i32) {
   *val += 3;
}

// allow async fn main -> Result
fn main() -> Result<(), ()> {
   test_enums();
   test_patterns();
   
   let big_num: &i64 = &50;
   let mut value = 5;
   
   if *big_num < MAX_VALUE {
      io::println(big_num);
   } else {
      return "failed!";
   }
   
   test_assignment(&mut value);
   io::println(value);

   io::println(tester());
   get_message("testing!");
      
   Result::Ok(())
}

// only checks type if not implicit return
fn tester() -> &str {
   get_message("testing!")
}