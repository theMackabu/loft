pub mod std {
   pub mod io {
      use core::io::stdout;
   
      pub fn print(value: &str) {
         io::stdout().write(value);
      }
   
      pub fn println(value: &str) {
         io::stdout().write(value);
         io::stdout().write("\n");
      }
   }
}

use std::io;

// defaults to other.lo or other/mod.lo
use other::something;
use testing::util;

#[path="other/another.lo"]
use another;

const MAX_VALUE: &i64 = 100;
static GREETING: &str = "Hello";

// Type error: TypeMismatch { expected: "&str", found: "i32", location: "in function main" }
// even though its here
// when changing return type "location"
fn get_message(input: &str) -> &str {
   io::println(input);
    
   GREETING
}

pub enum Shape {
   Circle(f64),
   Rectangle(f64, f64),
   Triangle { base: f64, height: f64 },
}

fn test_enums() {
   let circle = Shape::Circle(5.0);
   let rect = Shape::Rectangle(4.0, 6.0); 
   // let triangle = Shape::Triangle { base: 3.0, height: 4.0 };

   io::println(circle);
   io::println(rect);
   // io::println(triangle);
}

fn test_assignment(val: &mut i32) -> &mut i32 {
   *val += 3;
   return val;
}

// allow async fn main -> Result
fn main() -> Result<(), &str> {
   test_enums();
      
   let big_num: &i64 = 50;
   let mut value = 5;
   
   if big_num < MAX_VALUE {
      io::println(big_num);
   } else {
      return Result::Err("too big!");
   }
   
   let mut val2 = test_assignment(&mut value);
   *val2 += 10;
      
   io::println(value);

   io::println(tester());
   get_message("testing!");
   
   let nest = {
      let y = 10;
      let z = 20;
      y + z
   };
   
   io::println(nest);
   
   let (a, mut b) = (1, 1);
   let c = (1, 2, 3);
   
   b += 2;

   io::println(a);
   io::println(b);
   io::println(c);
   
   io::println(c.0);
   io::println(c.1);   
   io::println(c.2); 

   Result::Ok(())
}

// only checks type if not implicit return
fn tester() -> &str {
   get_message("testing!")
}