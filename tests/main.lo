pub mod std {
   pub mod io {
      use core::io::stdout;
   
      pub fn print(value: &str) {
         io::stdout().write(value);
      }
   
      pub fn println(value: &str) {
         io::stdout().write(value);
         io::stdout().write("\n");
      }
   }
}

// update lexer to support
// pub mod util;

use std::io;

// defaults to other.lo or other/mod.lo
use other::something;
use testing::util;

#[path="other/another.lo"]
use another;

const MAX_VALUE: i32 = 100;
static GREETING: &str = "Hello";

// Type error: TypeMismatch { expected: "&str", found: "i32", location: "in function main" }
// even though its here
// when changing return type "location"
fn get_message(input: &str) -> &str {
   io::println(input);
    
   GREETING
}

// parse enums
pub enum Result<T, E> {
   Ok(T),
   Err(E),
}

pub enum Option<T> {
   None,
   Some(T),
}

fn test_enums() {
   let success = Result::Ok(42);
   let failure = Result::Err("error message");
   let maybe = Option::Some(123);
   let nothing = Option::None;
   
   let result = match success {
      Result::Ok(n) => n,
      Result::Err(_) => -1,
   };
   
   
   let error_msg = match failure {
      Result::Ok(_) => "success",
      Result::Err(msg) => msg,
   };
   
   let opt_value = match maybe {
      Option::Some(x) => x,
      Option::None => 0,
    };
   
   let default = match nothing {
      Option::Some(x) => x,
      Option::None => 999,
   };
   
   io::println(result);     // should print 42
   io::println(error_msg);  // should print "error message"
   io::println(opt_value);  // should print 123
   io::println(default);    // should print 999
}

// allow async fn main -> Result
fn main() -> i32 {
   test_enums();
   
   // let x = 42.0 as f32; // implement as
   // let x: f32 = 42.0; // allow this to cast f32
   
   let x: i64 = 42i64;
   let mut a = 0;
   
   let y = &x;  // reference
   let z = *y;  // dereference
   
   if z < MAX_VALUE {
      io::println(x);
   } else {
      return "failed!";
   }
      

      
   // allow this
   // Ok(get_message("testing!"))
   
   // allow this syntax wise
   // a += 10;
   
   // io::println(a);
   
   io::println(tester());
   get_message("testing!");
   
   return a;
}

// only checks type if not implicit return
fn tester() -> &str {
   get_message("testing!")
}