#![allow(dead_code)]

pub use std::module::etc;

use math::add;
use project_name::something;
use lib_name::something as something_else;

mod something {}
pub mod something {}

mod math {
   pub fn add(x: i32, y: i32) -> i32 {
      x + y
   }
}

struct Point<T> {
   x: T,
   y: T
}

pub struct Point {
   x: i32,
   y: i32
}

struct Point {
   pub x: i32,
   y: i32
}

pub struct Point<T, U> {
   pub x: T,
   pub y: U,
   private_field: i32
}

struct Point2 {
   x: i32,
   y: i32
}

impl Point2 {
   pub fn new() -> Self {
      Self { x: 10, y: 10 }
   }
   
   pub async fn display(&self) -> String {
      format!("({}, {})", self.x, self.y)
   }
   
   fn process3(&mut self) {} 
   
   fn process4(&self) {} 
   
   fn process5(self) {} 
}

struct Dot {
   y: i32
}

#[derive(Clone)]
struct Point3 {
   x: Dot,
}

type TypeAlias<T> = MyStruct<T>;
type Point = (u8, u8);
type SomeRes<T> = Result<T, ()>;

const PRIVATE: i32 = 42;
static COUNTER: AtomicI32 = AtomicI32::new(0);

pub const PUBLIC: i32 = 42;

let empty;
let y = x + 10;

let slice: [i32] = [1, 2, 3];
let arr: [i32; 3] = [1, 2, 3];

let mut z = "hello world";
let mut test = Point { x: 1, y: 2 };

let nest = {
   let y = 10;
   let z = 20;
   y + z
};

fn test() {
   if test {
      let y = 20;
      let z = 30;
      y + z
   } else {
      let y = 10;
      y * 2
   }
   
   if a == b {}
   
   if !a {}
   
   if a != b {}
   
   if a & a {}
   
   if a && a {}
   
   if a || a {}
   
   if a | a {}
}

fn main(args: Vec<String>) -> Result<i32, ()>  {
   let y = if 12 * 15 > 150 {
      "Bigger"
   } else {
      "Smaller"
   };
   
   {
      let y = Err("error");
      let z = Some(123);
      let w = None;

      let x = Ok(42).unwrap();
      let y = Some(123).unwrap_or(0);
      let z = Err("error").ok();

      let is_ok = result.is_ok();
      let is_some = option.is_some();
      let value = Ok(42).ok().unwrap_or(0);
   }
   
   test();
      
   obj.method().field = value;
   
   test.test = "test";
   
   test.test();
   
   file.read()?;
   
   get_value()?;
   
   obj.method()?;
   
   obj.method()?.other_method()?;
   
   io::println(test[2]);
   io::println(test["2"]);
   
   module::function();
   namespace::module::function();
   
   String::new();
   let test: Vec<i32> = Vec::with_capacity(10);
   
   let vec_units = Vec::<i32>::with_capacity(10);
   
   let x: module::Type = value;
   
   let y: outer::inner::Type<T> = value;
      
   let point = Point { x: 1, y: 2 };
   
   let point2 = Point { x, y };
   
   let point3 = Point { x, y: 42 };
   
   let x = 42 as f32 + 1.0;
   
   let y = (42 + 1) as f32;

   return Ok(0);
}

pub fn normal_function() {}

async fn async_function() {}

pub async fn public_async_function() {}

let result = some_future.await;

let text = r"Hello\nWorld";

let text = "Hello\nWorld"; 

let text = r"
   This is a
   multi-line string
";

42;          // integer without type suffix
42i32;       // 32-bit signed integer
42u64;       // 64-bit unsigned integer
3.14;        // float without type suffix
3.14f32;     // 32-bit float
3.14f64;     // 64-bit float
1e-10;       // scientific notation
1.23e+4f32;  // scientific notation with type suffix

let msg = format!("Hello {name}!");

let vec = vec![1, 2, 3];

let map = map! {"key": "value"};

let set = set! { 1, 2, 3 };

fn divide(x: i32, y: i32) -> Result<i32, String> {
   if y == 0 {
      Err("division by zero")
   } else {
      Ok(x / y)
   }
}

fn process1(data: &mut Vec<i32>) {} 

fn process2(mut data: &mut Vec<i32>) {} 

fn analyze1(data: &Vec<i32>) {}

fn analyze2(data: &String) {}

fn analyze(data: Vec<i32>) {}

fn transform<T>(value: Option<T>) {}

fn map<T, U>(list: [T], f: fn(T) -> U) -> [U] {}

let add = |x: i32, y: i32| x + y;

let transform = |value: Option<T>| value.map(|x| x + 1);

let process = |data: Vec<String>| {};

let test = |args| {}; 

let test = |x, y, z| {};   

let test = |_| {};

let test = || {};

let test = |x| x + 1;     

let test = async |x| {             
   let y = x + 1;
   y * 2
};

let r = &thing;
let rm = &mut some;

let p = *ptr;
let rp = **thing;
let rp = &*thing;

let x: (i32, String) = (42, "hello".to_string());
let unit: () = ();
let single_tuple: (i32,) = (1,);

fn test() {
   async {}
}

say_hello!();

macro_rules! say_hello {
   () => {
      println!("Hello!")
   };
}

macro_rules! vec_custom {
   () => {
      Vec::new()
   };
   ($($elem:expr),+ $(,)?) => {{
      let mut v = Vec::new();
      $(
         v.push($elem);
      )+
      v
   }};
}

macro_rules! log {
   (error, $($arg:tt)*) => {
      println!("[ERROR] {}", format!($($arg)*))
   };
   (warn, $($arg:tt)*) => {
      println!("[WARN] {}", format!($($arg)*))
   };
   (info, $($arg:tt)*) => {
      println!("[INFO] {}", format!($($arg)*))
   };
}

pub macro_rules! count_exprs {
   () => { 0 };
   ($_head:expr $(, $tail:expr)*) => {
      1 + count_exprs!($($tail),*)
   }
}

pub macro_rules! matrix {
   ($( $( $x:expr ),+ );+ $(;)?) => {
      {
         let mut m = Vec::new();
         $(
            let row = vec_custom![$($x),+];
            m.push(row);
         )+
         m
      }
   }
}

if Foo::Bar == a {}

if let Some(_) = something {}

if let Err(_) = test() {}

if let Foo::Bar = a_value {}

match value {
   0 => "zero",
   _ => "not zero"
}

match value {
   0i32 => "zero",
   0u8 => "unsigned zero",
   1.0f32 => "one float",
   -1i64 => "negative one",
   -1.0f64 => "negative one float",
   n if n < 0 => "negative",
   _ => "positive"
}

match enum_stuff {
   Enum::EE => {},
   Enum::Wee => {},
}

match res {
   Ok(_) => {},
   Err(_) => {},
}

match res {
   Some(_) => {},
   None => {},
}

loop { 
   println!("I live."); 
}

while condition {}

while let Some(y) = x.pop() {
   println!("y = {}", y);
}

while i < 10 {
   println!("hello");
   i = i + 1;
}

while let _ = 5 {
   println!("Irrefutable patterns are always true");
   break;
}

'label: while let PATS = EXPR {
    /* loop body */
}

'a: loop {
   'a: loop {
      break 'a;
   }
   print!("outer loop");
   break 'a;
}

for text in v {
   println!("I like {}.", text);
}

let (mut a, mut b) = (1, 1);

let result = loop {
   if b > 10 {
      break b;
   }
   let c = a + b;
   a = b;
   b = c;
};

'outer: loop {
   println!("Entered the outer loop");
   
   'inner: loop {
      println!("Entered the inner loop");
      break 'outer;
   }
   
   println!("This point will never be reached");
}


for i in 0..10 {}

pub trait Summary {
   fn summarize(&self) -> String;
   
   fn provided(&self) -> i32 {
      self.required() * 2
   }
}

impl Summary for Tweet {
   fn summarize(&self) -> String {
      format!("{}: {}", self.username, self.content)
   }
}
