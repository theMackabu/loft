pub enum Result<T, E> {
    Ok(T),
    Err(E),
}

pub enum Option<T> {
    None,
    Some(T),
}

impl Result<T, E> {
    pub fn is_ok(&self) -> bool {
        match *self {
            Ok(_) => true,
            _ => false
        }
    }
    
    // add err in core::panic
    pub fn unwrap(self) -> T {
        match self {
            Ok(t) => t,
            Err(_) => core::panic("called `Result::unwrap()` on an `Err` value"),
        }
    }
}

impl Option<T> {
    pub fn is_some(&self) -> bool {
        match *self {
            Some(_) => true,
            _ => false
        }
    }
    
    pub fn unwrap(self) -> T {
        match self {
            Some(v) => v,
            None => core::panic("called `Option::unwrap()` on a `none` value")
        }
    }
}

pub fn drop<T>(_x: T) {}

// pub struct String {
//     data: [u8],
// }
// 
// impl String {
//     pub fn new() -> String {
//         String { data: [] }
//     }
//     
//     pub fn push_str(&mut self, s: &str) {
//         for byte in s.bytes() {
//             self.data.push(byte);
//         }
//     }
//     
//     pub fn len(&self) -> usize {
//         self.data.len()
//     }
// }