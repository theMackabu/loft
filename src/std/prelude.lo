pub enum Result<T, E> {
   Ok(T),
   Err(E),
}

pub enum Option<T> {
   None,
   Some(T),
}

impl Result<T, E> {
   pub fn ok(self) -> Option<T> {
      match self {
         Ok(x) => Some(x),
         Err(_) => None,
      }
   }
    
   pub fn err(self) -> Option<E> {
      match self {
         Ok(_) => None,
         Err(x) => Some(x),
      }
   }
    
   pub fn is_ok(&self) -> bool {
      match self {
         Ok(_) => true,
         _ => false
      }
   }
    
   pub fn is_err(&self) -> bool {
      !self.is_ok()
   }
    
   pub fn unwrap(self) -> T {
      match self {
         Ok(t) => t,
         Err(e) => panic!("called `Result::unwrap()` on an `Err` value: {e}"),
      }
   }
    
   pub fn unwrap_err(self) -> E {
      match self {
         Ok(t) => panic!("called `Result::unwrap_err()` on an `Ok` value: {t}"),
         Err(e) => e,
      }
   }
    
   pub fn unwrap_or(self, default: T) -> T {
      match self {
         Some(x) => x,
         None => default,
      }
   }
    
   pub fn unwrap_or_default(self) -> T {
      match self {
         Some(x) => x,
         None => T::default(),
      }
   }
   
   pub fn unwrap_or_else<F: FnOnce() -> T>(self, op: F) -> T {
      match self {
         Some(x) => x,
         None => op(),
      }
   }
}

impl Option<T> {
   pub fn is_some(&self) -> bool {
      match self {
         Some(_) => true,
         _ => false
      }
   }
    
   pub fn is_none(&self) -> bool {
      !self.is_some()
   }
    
   pub fn unwrap(self) -> T {
      match self {
         Some(v) => v,
         None => panic!("called `Option::unwrap()` on a `none` value")
      }
   }
    
   pub fn unwrap_or(self, default: T) -> T {
      match self {
         Some(x) => x,
         None => default,
      }
   }
    
   pub fn unwrap_or_default(self) -> T {
      match self {
         Some(x) => x,
         None => T::default(),
      }
   }
   
   pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {
      match self {
         Ok(t) => t,
         Err(e) => op(e),
      }
   }
}

pub macro_rules! unreachable {
   () => {
      panic!("internal error: entered unreachable code")
   };
   ($($item:expr),*) => {
      panic!("internal error: entered unreachable code: {}", $($item),*)
   };
}

pub macro_rules! test_pass {
   () => {
      println!("\x1b[92m[test ok]\x1b[0m code ran correctly")
   };
   ($($item:expr),*) => {
      println!("\x1b[92m[test ok]\x1b[0m {}", $($item),*)
   };
}

pub macro_rules! test_fail {
   () => {
      println!("\x1b[91m[test failed]\x1b[0m unexpected error");
   };
   ($($item:expr),*) => {
      println!("\x1b[91m[test failed]\x1b[0m error: {}", $($item),*)
   };
}

pub macro_rules! test_eq {
   ($left:expr, $right:expr) => {
      match $left == $right {
         true => println!("\x1b[92m[test ok]\x1b[0m expected: `{}`", $left)
         false => println!("\x1b[91m[test failed]\x1b[0m provided: `{}` does not equal expected: `{}`", $left, $right),
      }
   };
}